<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lorenzo Posti">
<meta name="dcterms.date" content="2022-10-17">
<meta name="description" content="Independent datapoints are most often just a convenient idealisation which can even hamper your model inference at times and bias your results. Learn how to embrace the reality of correlated noise in the data and marginalize the parameter posteriors with Gaussian Processes.">

<title>Lorenzo Posti’s Machine Learning Quarto blog - Gaussian Processes: modelling correlated noise in a dataset</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Lorenzo Posti’s Machine Learning Quarto blog</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about_blog.html">
 <span class="menu-text">About this blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html">
 <span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/lposti/"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://scholar.google.com/citations?user=fDDcGdwAAAAJ&amp;hl=en"><i class="bi bi-mortarboard-fill" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lop.html"><i class="bi bi-book-half" role="img">
</i> 
 <span class="menu-text"> </span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Gaussian Processes: modelling correlated noise in a dataset</h1>
                  <div>
        <div class="description">
          Independent datapoints are most often just a convenient idealisation which can even hamper your model inference at times and bias your results. Learn how to embrace the reality of correlated noise in the data and marginalize the parameter posteriors with Gaussian Processes.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">gaussian_processes</div>
                <div class="quarto-category">bayesian</div>
                <div class="quarto-category">jupyter</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Lorenzo Posti </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 17, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#how-i-got-interested-in-gaussian-processes" id="toc-how-i-got-interested-in-gaussian-processes" class="nav-link active" data-scroll-target="#how-i-got-interested-in-gaussian-processes">How I got interested in Gaussian Processes</a></li>
  <li><a href="#gaussian-processes-gps-in-rotation-curve-modelling" id="toc-gaussian-processes-gps-in-rotation-curve-modelling" class="nav-link" data-scroll-target="#gaussian-processes-gps-in-rotation-curve-modelling">Gaussian Processes (GPs) in rotation curve modelling</a>
  <ul class="collapse">
  <li><a href="#definitions-and-rotation-curve-sampling" id="toc-definitions-and-rotation-curve-sampling" class="nav-link" data-scroll-target="#definitions-and-rotation-curve-sampling">Definitions and rotation curve sampling</a></li>
  <li><a href="#generating-rotation-curve-data-with-correlated-noise-using-gps" id="toc-generating-rotation-curve-data-with-correlated-noise-using-gps" class="nav-link" data-scroll-target="#generating-rotation-curve-data-with-correlated-noise-using-gps">Generating rotation curve data with correlated noise using GPs</a></li>
  <li><a href="#fitting-the-rotation-curve-with-or-without-gaussian-processes" id="toc-fitting-the-rotation-curve-with-or-without-gaussian-processes" class="nav-link" data-scroll-target="#fitting-the-rotation-curve-with-or-without-gaussian-processes">Fitting the rotation curve with or without Gaussian Processes</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="how-i-got-interested-in-gaussian-processes" class="level2">
<h2 class="anchored" data-anchor-id="how-i-got-interested-in-gaussian-processes">How I got interested in Gaussian Processes</h2>
<p>A few weeks ago I saw a paper passing on the arXiv by <a href="https://arxiv.org/abs/2209.08940">Aigrain &amp; Foreman-Mackey</a> which is a review on Gaussian Processes (GPs) from an astrophysical perspective - it is actually targeted for astronomical time-series. I had heard a lot of things about GPs before, but I never really had the time nor will to sit down an actually understand what they are about. That changed when I glanced over the review by Aigrain &amp; Foreman-Mackey, as I quickly realised a couple of things that caught my interest.</p>
<p>In particular, the thing that struck me the most is their Figure 3. This appears at the end of the first Section of the review, which is mostly dedicated to two <em>motivating examples</em> from astronomical time-series analysis (a very well-crafted first Section I must say!). This shows the fit of a mock exoplanet transit lightcurve by two models: the both share the same physics, which is also used to generate the mock dataset, but one takes into account the correlated noise in the data, while the other doesn’t and therefore works under the assumption that the datapoints are all uncorrelated and independent.</p>
<p>GPs are used to realistically represent the correlation in the time-series data typically observed for exoplanet transits and are an ingredient used to generate the mock dataset. So the final outcome of this controlled experiment is that <em>only the model that accounts for correlated data, modelled with a GP, is able to recover reasonably well the true physical parameters, while the other</em> <strong>model without a GP infers a severely biased result</strong>.</p>
<p>It is interesting to notice that in this example the GP introduces another layer of uncertainty in the model (i.e.&nbsp;how are the data correlated) over which we have to marginalise in order to arrive at the final prediction for the physical parameters. This means that <em>the simple model that treats the data as independent is very confidently inferring a biased result (with relatively high accuracy), as opposed to the model with a GP which is instead less accurate, but unbiased.</em></p>
</section>
<section id="gaussian-processes-gps-in-rotation-curve-modelling" class="level2">
<h2 class="anchored" data-anchor-id="gaussian-processes-gps-in-rotation-curve-modelling">Gaussian Processes (GPs) in rotation curve modelling</h2>
<p>In this notebook I’m going to explore how we can use GPs in modelling rotation curves of galaxies. Often - pretty much always - circular velocity measurements in galaxies are treated as independent and parametrized rotation curve models are fitted to such datasets without worrying too much if that is a reasonable assumption. Given that most HI rotation curves are derived with a <a href="https://ui.adsabs.harvard.edu/abs/1974ApJ...193..309R/abstract">tilted-ring model</a>, I am unconfortable with assuming that each datapoint in a rotation curve is actually independent from all the others, since adjacent rings can easily enter the line-of-sight of a given radius.</p>
<p>For this reason I am going to generate a mock rotation curve dataset where the points are actually correlated. This will be done using a GP. Then I will be fitting this dataset with two models: one assuming that the data are independent, and another taking into account the correlated noise.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1 <span class="im">import</span> make_axes_locatable</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jaxopt</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tinygp <span class="im">import</span> GaussianProcess, kernels</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpyro</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> corner</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>jax.config.update(<span class="st">"jax_enable_x64"</span>, <span class="va">True</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config Completer.use_jedi <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="definitions-and-rotation-curve-sampling" class="level3">
<h3 class="anchored" data-anchor-id="definitions-and-rotation-curve-sampling">Definitions and rotation curve sampling</h3>
<p>Define the mathematical functions for the galaxy rotation curves</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>G, H, Dc <span class="op">=</span> <span class="fl">4.301e-9</span>, <span class="dv">70</span>, <span class="fl">200.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># accessory functions</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jax_fc(x): <span class="cf">return</span> jnp.log(<span class="dv">1</span><span class="op">+</span>x)<span class="op">-</span>x<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>x)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jax_Vvir(Mh): <span class="cf">return</span> jnp.sqrt((Dc<span class="op">*</span>(H)<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">**</span>(<span class="fl">1.</span><span class="op">/</span><span class="fl">3.</span>) <span class="op">*</span> (G<span class="op">*</span>Mh)<span class="op">**</span>(<span class="fl">2.</span><span class="op">/</span><span class="fl">3.</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jax_Rvir(Mh):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    rho_hat <span class="op">=</span> <span class="fl">4.</span> <span class="op">/</span> <span class="fl">3.</span> <span class="op">*</span> np.pi <span class="op">*</span> Dc <span class="op">*</span> (<span class="fl">3.</span> <span class="op">*</span> (H)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="fl">8.</span> <span class="op">*</span> np.pi <span class="op">*</span> G))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1e3</span> <span class="op">*</span> ((Mh <span class="op">/</span> rho_hat)<span class="op">**</span>(<span class="fl">1.</span><span class="op">/</span><span class="fl">3.</span>))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># actual rotation curve</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jax_vhalo(params, R):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    Mh, cc <span class="op">=</span> <span class="dv">10</span><span class="op">**</span>params[<span class="st">'log_mh'</span>], <span class="dv">10</span><span class="op">**</span>params[<span class="st">'log_c'</span>]    </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    rv <span class="op">=</span> jax_Rvir(Mh)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.sqrt(jax_Vvir(Mh)<span class="op">**</span><span class="dv">2</span><span class="op">*</span>rv<span class="op">/</span>R<span class="op">*</span>jax_fc(cc<span class="op">*</span>R<span class="op">/</span>rv)<span class="op">/</span>jax_fc(cc)) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Lat’s now plot a randomly sampled rotation curve with a typical error on each datapoint of 8 km/s. As a first step, we will assume that each datapoint is independent and thus we will sample from a Gaussian noise distribution for each measurement.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>lmh, lc, verr <span class="op">=</span> <span class="dv">12</span>, <span class="fl">0.95</span>, <span class="fl">10.0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># generating independent datapoints with Gaussian errors</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="fl">0.1</span>, <span class="dv">50</span>, size)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x) <span class="op">+</span> rng.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>verr, size<span class="op">=</span>size)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>fig,ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">5</span>), nrows<span class="op">=</span><span class="dv">2</span>, gridspec_kw<span class="op">=</span>{<span class="st">'height_ratios'</span>:(<span class="fl">0.65</span>,<span class="fl">0.35</span>)})</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># rotation curve</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(x, jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x), <span class="st">'--'</span>, c<span class="op">=</span><span class="st">'tab:pink'</span>, label<span class="op">=</span><span class="st">'true mean'</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].errorbar(x, y, yerr<span class="op">=</span>verr, fmt<span class="op">=</span><span class="st">'.'</span>, c<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'data'</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">'lower right'</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'velocity'</span>)<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># residuals</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, ls<span class="op">=</span><span class="st">'--'</span>, c<span class="op">=</span><span class="st">'tab:pink'</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].errorbar(x, y<span class="op">-</span>jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x), yerr<span class="op">=</span>verr, fmt<span class="op">=</span><span class="st">'.'</span>, c<span class="op">=</span><span class="st">'k'</span>, lw<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'radius'</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'residuals'</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylim(<span class="op">-</span><span class="dv">60</span>,<span class="dv">60</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>In the simple case plotted above we have generated the points with the implicit assumption that each datapoint was independent from all the others. This is why mathematically we simply added a Gaussian noise term to the median curve when defining <code>y</code>. In the residuals plot, the fact that each datapoint is independent becomes apparent since there is no clear trend in the residuals as a function of radius.</p>
<p>However, in practice this is rarely the case with astronomical observations, since typically instrumental characteristics of the telescope and physical processes make the measurement of a single datapoint to have a non-negligible dependence on some other datapoints. Most of the times when modelling astrophysical data we do not know precisely if and which measurements are correlated with which others, so it is in our best interest to employ a modelling technique that allows for correlated datapoints, instead of assuming they are independent. This is where GPs come into play.</p>
</section>
<section id="generating-rotation-curve-data-with-correlated-noise-using-gps" class="level3">
<h3 class="anchored" data-anchor-id="generating-rotation-curve-data-with-correlated-noise-using-gps">Generating rotation curve data with correlated noise using GPs</h3>
<p>Let’s now use GPs to generate a new set of datapoints, but this time they will be correlated to one another. To specify this correlation we need to define a <code>kernel</code> or a covariance function which, in the simplest case that we are using here, is a function only of the physical distance of each point (absolute or L1 distance).</p>
<p>Kernels that depend only of the distance of points are called <em>stationary</em>. A very common kernel function used in GPs is the so-called <em>radial basis function (RBF)</em> or exponential-squared, since <span class="math inline">\(k(x_i, x_j) \propto \exp\left[-\frac{1}{2}(d_{ij}/s)^2\right]\)</span>, where <span class="math inline">\(d_{ij}=|x_i-x_j|\)</span> is the distance of the two datapoints, while <span class="math inline">\(s\in\mathbb{R}\)</span> is a scale parameter.</p>
<section id="build-the-gp-with-tinygp" class="level4">
<h4 class="anchored" data-anchor-id="build-the-gp-with-tinygp">Build the GP with tinygp</h4>
<p>We define the GP as follows using the library <a href="https://tinygp.readthedocs.io/en/stable/index.html">tinygp</a>.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_gp(params, x, yerr):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> <span class="dv">10</span><span class="op">**</span>params[<span class="st">'log_amp'</span>]<span class="op">*</span>kernels.ExpSquared(<span class="dv">10</span><span class="op">**</span>params[<span class="st">'log_scl'</span>], distance<span class="op">=</span>kernels.distance.L1Distance())</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> GaussianProcess(kernel, </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                           x, </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                           diag<span class="op">=</span>yerr<span class="op">**</span><span class="dv">2</span>, </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                           mean<span class="op">=</span>partial(jax_vhalo, params)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                          )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This GP has 2 adjustable parameters: an amplitude <code>log_amp</code> and a scale <code>log_scl</code> (both defined in log). We build the GP by passing it the kernel function, the set of datapoints (just <code>x</code>, not the velocity measurements), the measured uncertainty of the measurements, and the mean function that needs to be added to the noise generated by the GP.</p>
<p>What the library is doing is just building a full covariance matrix on the dataset <code>x</code> using the kernel function provided. The value that we pass on the <code>diag</code> argument will be considered as an additional variance to be added to the covariance matrix.</p>
<p>Let’s now initialize a GP with some amplitude and scale parameters and let’s sample random datapoints from its covariance matrix.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> {<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>          <span class="st">'log_amp'</span>:jnp.log10(<span class="fl">300.0</span>), <span class="st">'log_scl'</span>:jnp.log10(<span class="fl">5.0</span>)}</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the GP and sample from it</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>gp   <span class="op">=</span> build_gp(params, x, verr)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># vm   = gp.sample(jax.random.PRNGKey(11))</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>vm   <span class="op">=</span> gp.sample(jax.random.PRNGKey(<span class="dv">33</span>))</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>e_vm <span class="op">=</span> np.sqrt(gp.variance)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here <code>gp.sample</code> gets a random realization of y-measurements on the <code>x</code>-array. We can define their standard <em>errorbars</em> by just taking the variances (i.e.&nbsp;diagonal of the covariance matrix).</p>
</section>
<section id="the-covariance-matrix" class="level4">
<h4 class="anchored" data-anchor-id="the-covariance-matrix">The covariance matrix</h4>
<p>Just to help out with visualising the GP, let’s plot the covariance matrix for this problem.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plt_mat(ax, params, x, yerr):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    gp <span class="op">=</span> build_gp(params, x, yerr)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    xm1, xm2 <span class="op">=</span> jnp.meshgrid(x,x)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    zm <span class="op">=</span> np.zeros_like(xm1.flatten())</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(xm1.flatten())):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        zm[i]<span class="op">=</span>(gp.kernel.evaluate(xm1.flatten()[i], xm2.flatten()[i]))</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    im<span class="op">=</span>ax.matshow(zm.reshape((<span class="bu">len</span>(x), <span class="bu">len</span>(x))), extent<span class="op">=</span>(x.<span class="bu">min</span>(), x.<span class="bu">max</span>(), x.<span class="bu">max</span>(), x.<span class="bu">min</span>()))</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    divider <span class="op">=</span> make_axes_locatable(ax)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    cax <span class="op">=</span> divider.append_axes(<span class="st">"right"</span>, size<span class="op">=</span><span class="st">"5%"</span>, pad<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(im, cax<span class="op">=</span>cax)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="272">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fig,ax <span class="op">=</span> plt.subplots()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>plt_mat(ax, params, x, verr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Here each point is coloured according to the covariance <span class="math inline">\(k(x_i,x_j)\)</span>. It is highest along the diagonal, where <span class="math inline">\(k(x_i,x_i)=300\)</span> km<span class="math inline">\(^2\)</span>/s<span class="math inline">\(^2\)</span>, implying a standard uncertainty on each data point of <span class="math inline">\(\sigma=\sqrt{300+10^2}=20\)</span> km/s, where the term <span class="math inline">\(10^2\)</span> comes from adding the measured uncertainties to the covariance matrix (the <code>diag</code> argument in <code>GaussianProcess</code>). Given the kernel function and the scale of <span class="math inline">\(5\)</span> that we used in this example, we can see that each datapoint has a significant correlation with all the points closer than ~10.</p>
</section>
<section id="sampling-the-rotation-curve-with-correlated-noise" class="level4">
<h4 class="anchored" data-anchor-id="sampling-the-rotation-curve-with-correlated-noise">Sampling the rotation curve with correlated noise</h4>
<p>Finally, let’s plot the sampled rotation curve and its residuals and let’s compare them with the uncorrelated case above.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fig,ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">5</span>), nrows<span class="op">=</span><span class="dv">2</span>, gridspec_kw<span class="op">=</span>{<span class="st">'height_ratios'</span>:(<span class="fl">0.65</span>,<span class="fl">0.35</span>)})</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># rotation curve</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(x, jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x), <span class="st">'--'</span>, c<span class="op">=</span><span class="st">'tab:pink'</span>, label<span class="op">=</span><span class="st">'true mean'</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].errorbar(x, vm, yerr<span class="op">=</span>e_vm, fmt<span class="op">=</span><span class="st">'.'</span>, c<span class="op">=</span><span class="st">'C0'</span>, lw<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'data'</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">'lower right'</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'velocity'</span>)<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># residuals</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, ls<span class="op">=</span><span class="st">'--'</span>, c<span class="op">=</span><span class="st">'tab:pink'</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].errorbar(x, vm<span class="op">-</span>jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x), yerr<span class="op">=</span>e_vm, fmt<span class="op">=</span><span class="st">'.'</span>, c<span class="op">=</span><span class="st">'C0'</span>, lw<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'radius'</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'residuals'</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylim(<span class="op">-</span><span class="dv">60</span>,<span class="dv">60</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We do see quite a lot of structure in the residuals plot this time! This is in stark contrast to the picture we had when generating datapoints independently. This time each measurements <em>feels</em> the influence of the other measurements closer than ~10 in radius, thus the rotation curve starts having significant trends above and below the mean.</p>
<p>When fitting the rotation curve these trend can be misinterpreted as signal, instead of just correlated noise, and this can potentially bias our inference on the curve parameters quite significantly. We see below an example of this.</p>
</section>
</section>
<section id="fitting-the-rotation-curve-with-or-without-gaussian-processes" class="level3">
<h3 class="anchored" data-anchor-id="fitting-the-rotation-curve-with-or-without-gaussian-processes">Fitting the rotation curve with or without Gaussian Processes</h3>
<p>Let’s now consider the rotation curve generated with the GP above, i.e.&nbsp;the blue set of points, and let’s build a model to fit it. The model is the same <code>jax_vhalo</code> function that we used to generate the data, which has 2 free parameters: a mass <code>log_mh</code> and a concentration <code>log_c</code>.</p>
<p>We run the fit in a Bayesian framework and in particular with an MCMC sampler using a standard <span class="math inline">\(\chi^2\)</span> log-likelihood on the observed datapoints. We impose a uniform prior on <code>log_mh</code> and normal prior on <code>log_c</code>, whose mean follows the well-known mass-concentration relation of dark matter halos in <span class="math inline">\(\Lambda\)</span>CDM <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.441.3359D/abstract">(Dutton &amp; Maccio’ 2014)</a>.</p>
<p>We use the library <a href="https://num.pyro.ai/en/latest/index.html#">numpyro</a> to define the model and to run the MCMC sampling. In particular, numpyro uses a state-of-the-art Hamiltonian <em>No U-Turn Sampler (NUTS)</em> to derive the posterior of the parameters.</p>
<p>We run the fit two times: the first time, we treat the datapoints as independent and we have a “standard” Bayesian inference on the parameters; the second time, we allow the data to be correlated and we model their correlation with a GP with an exp-squared kernel that has two additional free parameters, an amplitude <code>log_amp</code> and a scale <code>log_scl</code>. We impose an uniformative uniform prior on the two parameters of the kernel.</p>
<section id="model-without-gp" class="level4">
<h4 class="anchored" data-anchor-id="model-without-gp">Model without GP</h4>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># radial grid to define the output of the GP</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>r_grid <span class="op">=</span> jnp.linspace(<span class="fl">0.1</span>, <span class="fl">50.0</span>, <span class="dv">1000</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model(t, y_err, y, use_gp<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># priors</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    log_mh <span class="op">=</span> numpyro.sample(<span class="st">'log_mh'</span>, numpyro.distributions.Uniform(<span class="fl">8.0</span>,  <span class="fl">14.0</span>)) </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    log_c  <span class="op">=</span> numpyro.sample(<span class="st">'log_c'</span>,  numpyro.distributions.Normal(<span class="fl">0.905</span><span class="op">-</span><span class="fl">0.101</span><span class="op">*</span>(log_mh<span class="op">-</span><span class="fl">12.0</span>), <span class="fl">0.15</span>)) </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># parameters of the underlying physical model</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {<span class="st">"log_mh"</span>: log_mh, </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>              <span class="st">"log_c"</span> : log_c}</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> use_gp:</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># branch WITH GPs</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># </span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># define kernel parameters</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        params[<span class="st">"log_amp"</span>] <span class="op">=</span> numpyro.sample(<span class="st">"log_amp"</span>, numpyro.distributions.Uniform(<span class="op">-</span><span class="fl">4.0</span>, <span class="fl">5.0</span>))</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        params[<span class="st">"log_scl"</span>] <span class="op">=</span> numpyro.sample(<span class="st">"log_scl"</span>, numpyro.distributions.Uniform(<span class="op">-</span><span class="fl">2.0</span>, <span class="fl">3.0</span>))</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># generate the GP</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        gp <span class="op">=</span> build_gp(params, t, y_err)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># sample the posterior</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        numpyro.sample(<span class="st">"y"</span>, gp.numpyro_dist(), obs<span class="op">=</span>y)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># calculate properties of the model</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> gp.mean_function(r_grid)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        numpyro.deterministic(<span class="st">"mu"</span>, mu)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>        numpyro.deterministic(<span class="st">"gp"</span>, gp.condition(y, r_grid, include_mean<span class="op">=</span><span class="va">False</span>).gp.loc)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># branch WITHOUT GPs</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">#</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># sample the posterior</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        numpyro.sample(<span class="st">"y"</span>, numpyro.distributions.Normal(jax_vhalo(params, t), y_err), obs<span class="op">=</span>y)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># calculate properties of the model</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        numpyro.deterministic(<span class="st">"mu"</span>, jax_vhalo(params, r_grid))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="sampling-the-posterior-with-numpyro" class="level4">
<h4 class="anchored" data-anchor-id="sampling-the-posterior-with-numpyro">Sampling the posterior with numpyro</h4>
<p>The <code>model</code> function above has the <code>numpyro</code> primitives like <code>numpyro.sample</code> that are used by the NUTS MCMC sampler to construct the posterior. Below we run the model the first time selecting the <code>use_gp=False</code> branch, i.e.&nbsp;assuming that the data are independent.</p>
<p>We launch 2 chains for 3000 steps (of which 1/3 of warmup) of the NUTS sampler, starting from a specific value of the parameters that is not too far from the truth (to convieniently speed up convergence). We then use the <a href="https://arviz-devs.github.io/arviz/"><code>arviz</code></a> package to evaluate some statistics on the posterior samples.</p>
<div class="cell" data-execution_count="345">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>sampler_wn <span class="op">=</span> numpyro.infer.MCMC(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    numpyro.infer.NUTS(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        model,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        dense_mass<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        target_accept_prob<span class="op">=</span><span class="fl">0.9</span>,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        init_strategy<span class="op">=</span>numpyro.infer.init_to_value(values<span class="op">=</span>{<span class="st">'log_mh'</span>:<span class="fl">11.0</span>, <span class="st">'log_c'</span>:<span class="fl">1.0</span>}),</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    num_warmup<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    num_samples<span class="op">=</span><span class="dv">3000</span>,</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    num_chains<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    progress_bar<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time sampler_wn.run(jax.random.PRNGKey(<span class="dv">11</span>), x, e_vm, vm)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>inf_data_wn <span class="op">=</span> arviz.from_numpyro(sampler_wn)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>arviz.summary(inf_data_wn, var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>sample: 100%|████████████████████████████████████████████████████████████████████| 4000/4000 [00:11&lt;00:00, 357.51it/s, 3 steps of size 8.43e-01. acc. prob=0.91]
sample: 100%|████████████████████████████████████████████████████████████████████| 4000/4000 [00:11&lt;00:00, 357.45it/s, 3 steps of size 7.96e-01. acc. prob=0.93]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 18.3 s, sys: 1.07 s, total: 19.4 s
Wall time: 23.4 s</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="345">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>log_mh</th>
      <td>11.897</td>
      <td>0.060</td>
      <td>11.786</td>
      <td>12.009</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>4581.0</td>
      <td>3535.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>log_c</th>
      <td>1.087</td>
      <td>0.058</td>
      <td>0.983</td>
      <td>1.200</td>
      <td>0.001</td>
      <td>0.001</td>
      <td>4758.0</td>
      <td>3911.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
<section id="explore-the-mcmc-samples-with-arviz" class="level4">
<h4 class="anchored" data-anchor-id="explore-the-mcmc-samples-with-arviz">Explore the MCMC samples with arviz</h4>
<p>The posterior has been successfully sampled and we can now have a look at the marginalized distributions of the two physical parameters, mass and concentration.</p>
<div class="cell" data-execution_count="346">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>arviz.plot_density(inf_data_wn, var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>], hdi_prob<span class="op">=</span><span class="fl">0.99</span>, colors<span class="op">=</span><span class="st">'k'</span>, shade<span class="op">=</span><span class="fl">0.1</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="model-with-gp" class="level4">
<h4 class="anchored" data-anchor-id="model-with-gp">Model with GP</h4>
<p>Let’s now repeat the fitting procedure, but this time for the <code>use_gp=True</code> branch of <code>model</code>, i.e.&nbsp;allowing for the data to be correlated.</p>
<div class="cell" data-execution_count="347">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>sampler <span class="op">=</span> numpyro.infer.MCMC(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    numpyro.infer.NUTS(</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        model,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        dense_mass<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        target_accept_prob<span class="op">=</span><span class="fl">0.9</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        init_strategy<span class="op">=</span>numpyro.infer.init_to_value(values<span class="op">=</span>{<span class="st">'log_mh'</span>:<span class="fl">11.0</span>, <span class="st">'log_c'</span>:<span class="fl">1.0</span>, </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>                                                          <span class="st">'log_amp'</span>:<span class="fl">1.0</span>, <span class="st">'log_scl'</span>:<span class="fl">0.5</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>                                                         }),</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    num_warmup<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    num_samples<span class="op">=</span><span class="dv">3000</span>,</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    num_chains<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    progress_bar<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time sampler.run(jax.random.PRNGKey(<span class="dv">11</span>), x, e_vm, vm, use_gp<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>inf_data <span class="op">=</span> arviz.from_numpyro(sampler)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>arviz.summary(inf_data, var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>, <span class="st">"log_amp"</span>, <span class="st">"log_scl"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>sample: 100%|████████████████████████████████████████████████████████████████████| 4000/4000 [00:21&lt;00:00, 183.03it/s, 7 steps of size 2.41e-01. acc. prob=0.97]
sample: 100%|███████████████████████████████████████████████████████████████████| 4000/4000 [00:14&lt;00:00, 273.18it/s, 31 steps of size 1.56e-01. acc. prob=0.97]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 1min, sys: 2.38 s, total: 1min 2s
Wall time: 44.9 s</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="347">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>mean</th>
      <th>sd</th>
      <th>hdi_3%</th>
      <th>hdi_97%</th>
      <th>mcse_mean</th>
      <th>mcse_sd</th>
      <th>ess_bulk</th>
      <th>ess_tail</th>
      <th>r_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>log_mh</th>
      <td>11.974</td>
      <td>0.261</td>
      <td>11.525</td>
      <td>12.476</td>
      <td>0.006</td>
      <td>0.004</td>
      <td>2440.0</td>
      <td>1578.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>log_c</th>
      <td>0.989</td>
      <td>0.142</td>
      <td>0.716</td>
      <td>1.258</td>
      <td>0.003</td>
      <td>0.002</td>
      <td>2553.0</td>
      <td>2809.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>log_amp</th>
      <td>2.723</td>
      <td>0.647</td>
      <td>1.929</td>
      <td>3.712</td>
      <td>0.039</td>
      <td>0.027</td>
      <td>942.0</td>
      <td>580.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>log_scl</th>
      <td>0.840</td>
      <td>0.233</td>
      <td>0.517</td>
      <td>1.143</td>
      <td>0.008</td>
      <td>0.008</td>
      <td>1543.0</td>
      <td>1419.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>In this case, we have two additional free parameters that are the amplitude and scale of the GP kernel. These can be considered as <em>nuisance</em> parameters in the present case, since we are only interested in the distributions of the two physical parameters marginalized over everything else.</p>
<p>The chain statistics summarized above look great, but let’s inspect the plot of the autocorrelation time to be extra sure that all the chains are converged and well-behaved.</p>
<div class="cell" data-execution_count="348">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>arviz.plot_autocorr(inf_data, var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>], max_lag<span class="op">=</span><span class="dv">200</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>From this plot we can see that the autocorrelation of both parameters for all chains tends to die out for sufficiently large lags. This confirms that the MCMC samples that we have derived are actually independent and can be reliably used to infer the posterior.</p>
<p>Let’s now compare the marginalized distributions of <code>log_mh</code> and <code>log_c</code> between the two modeling runs.</p>
<div class="cell" data-execution_count="349">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>arviz.plot_density([inf_data_wn, inf_data], var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>],</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                   data_labels<span class="op">=</span>[<span class="st">"independent data"</span>, <span class="st">"correlated data"</span>],</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                   hdi_prob<span class="op">=</span><span class="fl">0.99</span>, colors<span class="op">=</span>[<span class="st">'k'</span>,<span class="st">'C0'</span>], shade<span class="op">=</span><span class="fl">0.1</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We clearly see that if we working under the assumption of uncorrelated data the resulting posteriors are thinner and somewhat biased. On the other hand, by allowing the data to be correlated in the fit, as modelled by a GP, the resulting posterior are significantly wider and more uncertain, but are significantly less biased.</p>
</section>
<section id="comparing-the-2-models-with-a-corner-plot" class="level4">
<h4 class="anchored" data-anchor-id="comparing-the-2-models-with-a-corner-plot">Comparing the 2 models with a corner plot</h4>
<p>Let’s have a look at the <a href="https://corner.readthedocs.io/en/latest/">corner</a> plot of the marginalised posterior distribution in the mass-concentration space.</p>
<div class="cell" data-execution_count="393">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ranges <span class="op">=</span> [(<span class="fl">11.4</span>, <span class="fl">12.6</span>), (<span class="fl">0.5</span>, <span class="fl">1.4</span>)] <span class="co"># PRNG 33</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> corner.corner(inf_data_wn, bins<span class="op">=</span><span class="dv">40</span>, <span class="bu">range</span><span class="op">=</span>ranges, </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">"k"</span>, var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>], smooth<span class="op">=</span><span class="fl">1.0</span>, smooth1d<span class="op">=</span><span class="fl">1.0</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                   )</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> corner.corner(inf_data, bins<span class="op">=</span><span class="dv">40</span>, <span class="bu">range</span><span class="op">=</span>ranges, </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">"C0"</span>, var_names<span class="op">=</span>[<span class="st">"log_mh"</span>, <span class="st">"log_c"</span>], smooth<span class="op">=</span><span class="fl">1.0</span>, smooth1d<span class="op">=</span><span class="fl">1.0</span>,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>                    labels<span class="op">=</span>[<span class="st">"$\log\,M_h$"</span>, <span class="st">"$\log\,c$"</span>],</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>                    truths<span class="op">=</span>[params[<span class="st">'log_mh'</span>], params[<span class="st">'log_c'</span>]], truth_color<span class="op">=</span><span class="st">'tab:pink'</span>,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>                    fig<span class="op">=</span>fig)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># make legend</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.axes[<span class="dv">1</span>]</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>key_tr <span class="op">=</span> matplotlib.lines.Line2D([], [], color<span class="op">=</span><span class="st">'tab:pink'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, marker<span class="op">=</span><span class="st">'s'</span>, label<span class="op">=</span><span class="st">'truth'</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>key_nn <span class="op">=</span> matplotlib.lines.Line2D([], [], color<span class="op">=</span><span class="st">'k'</span>,    linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="st">'independent data'</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>key_gp <span class="op">=</span> matplotlib.lines.Line2D([], [], color<span class="op">=</span><span class="st">'C0'</span>,   linestyle<span class="op">=</span><span class="st">'-'</span>, label<span class="op">=</span><span class="st">'correlated data'</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">'upper right'</span>, handles<span class="op">=</span>[key_tr, key_nn, key_gp])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-17-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This figure shows more clearly how the first run of the fit, assuming independent data, infers a clearly biased (lower) mass and (higher) concentration. On the other hand, when including a GP in the model to account for correlations in the data the posterior on <span class="math inline">\(M_h\)</span> and <span class="math inline">\(c\)</span> becomes perfectly compatible with the true value within 1-<span class="math inline">\(\sigma\)</span>.</p>
</section>
<section id="predicted-rotation-curves-of-the-2-models" class="level4">
<h4 class="anchored" data-anchor-id="predicted-rotation-curves-of-the-2-models">Predicted rotation curves of the 2 models</h4>
<p>Finally, let’s plot the predicted rotation curves of the two models in comparison with the data.</p>
<div class="cell" data-execution_count="382">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get predictions excluding MCMC warmup phase</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>pred_wn <span class="op">=</span> sampler_wn.get_samples(group_by_chain<span class="op">=</span><span class="va">True</span>)[<span class="st">'mu'</span>][:,<span class="dv">1000</span>:,:].reshape((<span class="dv">4000</span>,<span class="dv">1000</span>))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>pred    <span class="op">=</span> sampler.get_samples(group_by_chain<span class="op">=</span><span class="va">True</span>)[<span class="st">'mu'</span>][:,<span class="dv">1000</span>:,:].reshape((<span class="dv">4000</span>,<span class="dv">1000</span>))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>pred_cd <span class="op">=</span> (sampler.get_samples(group_by_chain<span class="op">=</span><span class="va">True</span>)[<span class="st">'mu'</span>]<span class="op">+</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>           sampler.get_samples(group_by_chain<span class="op">=</span><span class="va">True</span>)[<span class="st">'gp'</span>])[:,<span class="dv">1000</span>:,:].reshape((<span class="dv">4000</span>,<span class="dv">1000</span>))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># get random subset</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>inds <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2000</span>, <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="396">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>fig,ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">16</span>,<span class="dv">6</span>), ncols<span class="op">=</span><span class="dv">3</span>, nrows<span class="op">=</span><span class="dv">2</span>, gridspec_kw<span class="op">=</span>{<span class="st">'height_ratios'</span>:(<span class="fl">0.65</span>,<span class="fl">0.35</span>)})</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> commons(ax, i):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rotation curve</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].plot(x, jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x), <span class="st">'--'</span>, c<span class="op">=</span><span class="st">'tab:pink'</span>, label<span class="op">=</span><span class="st">'true mean'</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].errorbar(x, vm, yerr<span class="op">=</span>e_vm, fmt<span class="op">=</span><span class="st">'.'</span>, c<span class="op">=</span><span class="st">'C0'</span>, lw<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'data'</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].legend(loc<span class="op">=</span><span class="st">'lower right'</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>,i].set_ylabel(<span class="st">'velocity'</span>)<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># residuals</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].axhline(y<span class="op">=</span><span class="dv">0</span>, ls<span class="op">=</span><span class="st">'--'</span>, c<span class="op">=</span><span class="st">'tab:pink'</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].errorbar(x, vm<span class="op">-</span>jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, x), yerr<span class="op">=</span>e_vm, fmt<span class="op">=</span><span class="st">'.'</span>, c<span class="op">=</span><span class="st">'C0'</span>, lw<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].set_xlabel(<span class="st">'radius'</span>)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].set_ylabel(<span class="st">'residuals'</span>)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>,i].set_ylim(<span class="op">-</span><span class="dv">60</span>,<span class="dv">60</span>)<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>commons(ax,<span class="dv">0</span>)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>commons(ax,<span class="dv">1</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>commons(ax,<span class="dv">2</span>)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">0</span>].plot(r_grid, pred_wn[inds].T, <span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">1</span>].plot(r_grid, pred[inds].T, <span class="st">'C0'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">2</span>].plot(r_grid, pred_cd[inds].T, <span class="st">'C2'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">0</span>].plot(r_grid, (pred_wn[inds]<span class="op">-</span>jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, r_grid)).T, <span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">1</span>].plot(r_grid, (pred[inds]<span class="op">-</span>jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, r_grid)).T, <span class="st">'C0'</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>,<span class="dv">2</span>].plot(r_grid, (pred_cd[inds]<span class="op">-</span>jax_vhalo({<span class="st">'log_mh'</span>:lmh, <span class="st">'log_c'</span>:lc}, r_grid)).T, <span class="st">'C2'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>)<span class="op">;</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">0</span>].set_title(<span class="st">"Model assuming independent data"</span>)<span class="op">;</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">1</span>].set_title(<span class="st">"Model with GP: correlated data"</span>)<span class="op">;</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>,<span class="dv">2</span>].set_title(<span class="st">"Model with GP "</span><span class="op">+</span><span class="vs">r"$\rm\bf conditioned$"</span><span class="op">+</span><span class="st">" to data"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2022-10-17-gaussian-processes_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>In the left-hand panels we compare 20 random samples of the predicted rotation curve for the first iteration of the model, i.e.&nbsp;the one treating each datapoint as independent. We see that the model rotation curves (in black) tend to overshoot the mean at small radii and tend to fall below it at large radii - this becomes particularly clear in the residuals plot. The reason for this discrepancy is that this model finds a biased result, predicting a higher concentration and a lower mass than the true values.</p>
<p>The middle panels similarly compare samples of the predictions of the second model, i.e.&nbsp;the one that uses GPs to model correlations among successive datapoints. We see that while the prediction of the rotation curve (in blue) becomes much less accurate, it is now unbiased. In fact, the true mean rotation curve that we used to generate the dataset is very well encompassed by the random samples of this model.</p>
<p>The right panels demonstrate why such a large variety of rotation curve shapes in the blue model is consistent with the dataset. In fact, each blue curve is itself a GP and when <a href="https://en.wikipedia.org/wiki/Conditioning_(probability)">conditioning</a> it to the measurements we obtain the green curves in the right panels, which are all consistent with the data (reduced <span class="math inline">\(\chi^2\)</span> less than unity).</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>